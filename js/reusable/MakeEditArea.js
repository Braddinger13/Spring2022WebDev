// Expecting params.fieldDefn, an array of objects with these properties: 
//   *  fieldName (required)
//   *  prompt (optional, will use the fieldName as prompt, if not supplied)
//   *  disabled (boolean, optional) - makes the input box disabled, user cannot put data in.
//   *  pickList (boolean, optional) - does not put in an input box (let the calling code do that).
//   *  password (boolean, optiona) - set the "type" of the <input> tag to be "password" (letters 
//      show up as dots.

// Creates an HTML table with one row per object in parms.fieldDefn. Each row has three columns: 
//   *  1st column is for field prompt. 
//   *  2nd column is for input box <input type="text"/>
//   *  3rd column is for possible validation error message. 

// Then there is one last row after all the rows per field: 
//   *  1st column is for a submit button (might be insert save or update save)
//   *  the 2nd and 3rd columns (spanned together) will hold a "form level" message (OK or error).

// For each field (as specified by params.fieldDefn, there is a public object 
// (accessible from editArea object using associative array notation with the 
// fieldName as "index"). Each such public object has these properties: 
//  * inputBox (reference to the input box <input type="text"/> so we can get the user's input
//  * errorTd so we can place field level validation messges. 
//  * inputTd so we can place a select tag (instead of input box) inside the second column of the row. 
//            (this is for Foreign Key type fields that use a select tag).

function MakeEditArea(params) {

    function makeInputRow(fieldDef) {

        var obj = {}; // this will hold references to the input box and the error td for the 
        // given field name.

        var row = Utils.make({// Inject a row into the table 
            htmlTag: "tr",
            parent: validationTable
        });
        Utils.make({// first td of row will hold promptText
            htmlTag: "td",
            innerHTML: fieldDef.prompt || fieldDef.fieldName, // use fieldName as prompt for now, later promptText,
            parent: row
        });
        obj.inputTd = Utils.make({// second td of row will hold user input
            htmlTag: "td",
            parent: row
        });

        if (fieldDef.pickList) {
            // If the field is a FK (select tag), do nothing. 
            // Let the calling code put in the select tag that they want.
        } else { // insert an input box, possibly make it disabled and/or set it to type="password"
            // store reference to this input box. we need to access it programatically 
            // (to find user's input).
            obj.inputBox = Utils.make({// place textbox in second td
                htmlTag: "input",
                parent: obj.inputTd
            });

            if (fieldDef.disabled) {
                obj.inputBox.setAttribute("disabled", true);
            }

            if (fieldDef.password) {
                obj.inputBox.setAttribute("type", "password");
            }
        }

        // store reference to the 3rd td that is for holding error messages, 
        // so we can access it programmatically.
        obj.errorTd = Utils.make({
            htmlTag: "td",
            parent: row,
            class: "error"
        });
        // obj has a reference to the inputBox and the errorTd (the two things 
        // we need to access programatically to do validation). Store this 
        // object into an associative array (using fieldName as key). 
        editArea[fieldDef.fieldName] = obj;
    } // makeInputRow


    // ****************************************************
    // ******* ENTRY POINT FOR MakeEditArea ***************

    // check parameter object, declare and initialize parameter variables.
    if (!params.fieldDefn || !params.fieldDefn[0]) {
        throw new Error("MakeEditArea requires a parameter object with property 'fieldDefn' - " +
                "an array of objects that define the fields for the Edit Area.");
        return;
    }
    var fieldDefn = params.fieldDefn;

    var editArea = document.createElement("div");
    editArea.classList.add("editArea");

    editArea.areaTitle = Utils.make({
        htmlTag: "h2",
        innerHTML: params.areaTitle || "Untitled",
        parent: editArea
    });

    var validationTable = Utils.make({
        htmlTag: "table",
        parent: editArea
    });

    // populate validationTable with rows. Each row has a column for field prompt, 
    // a column for input value, and a column for possible error message (generated by server). 
    for (var i = 0; i < fieldDefn.length; i++) {
        makeInputRow(fieldDefn[i]);
    }

    var lastRow = Utils.make({// Inject a row into the table 
        htmlTag: "tr",
        parent: validationTable
    });

    var firstCol = Utils.make({// Inject a row into the table 
        htmlTag: "td",
        parent: lastRow
    });

    editArea.button = Utils.make({// Inject a row into the table 
        htmlTag: "button",
        parent: firstCol
    });

    editArea.formMsg = Utils.make({// Inject a row into the table 
        htmlTag: "td",
        class: "error",
        parent: lastRow
    });

    editArea.formMsg.colSpan = 2; // form message spans two columns. 

    // create an object from the values typed into the page, then turn that object into JSON, 
    // URL encode it and return it.
    editArea.getDataFromUI = function () {

        var userInputObj = {};
        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // FK fields will have a select tag, not an inputBox. 
            // Let the calling code (that called MakeEditArea) put in the select tag values.
            if (editArea[fieldName].inputBox) {
                userInputObj[fieldName] = editArea[fieldName].inputBox.value;
            }
        }

        console.log("getDataFromUI - userInputObj on next line");
        console.log(userInputObj);

        return userInputObj;

    };

    // write the jsonObj (full of error messages) to the error message column of the 
    // HTML table in the editArea component.  
    editArea.writeErrorObjToUI = function (obj) {

        console.log("The error msg object from attempt to insert (see next line).");
        console.log(obj);

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;
            editArea[fieldName].errorTd.innerHTML = obj[fieldName];
        }

    }; // writeErrorObjToUI


    // write the jsonObj (full of error messages) to the error message column of the 
    // HTML table in the editArea component.  
    editArea.writeDbValuesToUI = function (obj) {

        console.log("The error msg object from attempt to insert (see next line).");
        console.log(obj);

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // pickLists (FK fields) do not have an input box, so skip them.
            if (editArea[fieldName].inputBox) {
                editArea[fieldName].inputBox.value = obj[fieldName];
            }
        }

    }; // writeErrorObjToUI

    // write "" (empty string) to all inputs. 
    editArea.blankInputs = function () {

        console.log("Blanking inputs in the edit area.");

        for (var i = 0; i < fieldDefn.length; i++) {
            var fieldName = fieldDefn[i].fieldName;

            // pickLists (FK fields) do not have an input box, so skip them.
            if (editArea[fieldName].inputBox) {
                editArea[fieldName].inputBox.value = "";
            }
        }
    }; // blankInputs

    return editArea;
}